
#define _SILENCE_AMP_DEPRECATION_WARNINGS
#include <iostream>
#include <amp.h>
#include<ppl.h>
#include<concurrent_vector.h>
#include<array>
#include<vector>
#include<tuple>
#include<algorithm>
#include<chrono>

using namespace std;
using namespace std::chrono;
using namespace concurrency;


int fib(int n) {
	if (n < 2)
		return n;
	return fib(n - 1) + fib(n - 2);
}
/*const int size = 5;

void CppAmpMethod() {
	const int size = 5;
	int aCPP[] = { 1,2,3,4,5 };
	int bCPP[] = {6,7,8,9,10};
	int sumCPP[size];
	array_view<const int, 1> a(size, aCPP);
	array_view<const int, 1> b(size, bCPP);
	array_view<int, 1> sum(size, sumCPP);
	sum.discard_data();
	parallel_for_each(
		sum.extent, [=](index<1> idx) restrict(amp)
		{
			sum[idx] = a[idx] + b[idx]; }
		
	);
	for (int i = 0; i < size; i++) {
		cout << sum[i] << "\n";
	}
}*/
int main()
{
	/*vector<accelerator> accelerators = accelerator::get_all();
	cout << accelerators.size() << "\n";
	for (size_t i = 0; i < accelerators.size(); i++)
		wcout << accelerator(accelerator::default_accelerator).description << endl;
	wcout << accelerators[0].get_dedicated_memory() << "\n";
	wcout << accelerators[0].get_device_path() << "\n";
	wcout << accelerators[0].get_supports_double_precision() << "\n";*/

	array <int, 6> a = { 16,17,18,19,30,31 };
	vector<tuple<int, int>> result1;
	concurrent_vector<tuple<int,int>> results2
	setlocale(LC_ALL, "rus");
	auto t0 = high_resolution_clock::now();
	for_each(begin(a), end(a), [&](int n)
		{
		result1.push_back(make_tuple(n, fib(n)));
		});
	auto t1 = high_resolution_clock::now();

}
